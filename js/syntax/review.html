<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=f, initial-scale=1.0">
	<title>Document</title>
</head>
<body>
<script>
	const myInstanceof = function(left, right) {
		const proto = right.prototype;
		left = left.__proto__;
		while(true) {
			if(left === proto) return true;
			if(left === null) return false;
			left = left.__proto__;
		}
	}
	const a = function() {}
	const b = new a();
	console.log(myInstanceof(b, a));

	const debounce = function(fn, delay) {
		let timeout = null;
		return function() {
			if(timeout) clearTimeout(timeout);
			const context = this;
			timeout = setTimeout(function() {
				fn.apply(context, [...arguments]);
			}, delay);
		}
	} 
	const throttle = function(fn, delay) {
		let flag = false;
		return function() {
			if(flag) return;
			flag = true;
			const context = this;
			setTimeout(function() {
				fn.apply(context, [...arguments]);
				flag = false;
			}, delay);
		}
	}


	const wait = (url) => {
		return new Promise((resolve, reject) => {
			setTimeout(() => { resolve(url) }, 1000 * Math.random());
		})
	}
    const multiRequest = (urls, max = 1) => {
    	return new Promise((resolve, reject) => {
    		let rest = urls.slice();
    		let finished = 0;
    		let currentIdx = 0;
    		let result = [];

    		const request = async (idx) => {
    			if(rest.length === 0) return;
    			currentIdx++;
    			const url = rest.shift();
    			try{
    				const res = await wait(url);
    				result[idx] = res;
    				finished++;
    				console.log(result);
    			}catch(e) {
    				reject(e);
    			}

    			if(finished === urls.length) return resolve(result);
    			request(currentIdx);
    		}

    		for(let i=0; i<max; i++) {
    			request(i);
    		}
    	})
    }
    multiRequest([1,3,5,6,9,12,44,56,100], 3).then(res => {
    	console.log(res)
    });


    const quickSort = (arr) => {
    	if(arr.length<=1) return arr;
    	let left = [],
    		right = [],
    		pivot = arr.splice(0,1);
		for(let i=0; i<arr.length; i++) {
			arr[i]>pivot ? right.push(arr[i]) : left.push(arr[i]);
		}
		return quickSort(left).concat(pivot, quickSort(right));
    }
    console.log(quickSort([13,43,1,9,22,7,11,1,6,9]));
    
    class eventEmitter {
    	constructor() {
    		this.event = {};
    	}
    	on(eventName, callback) {
    		this.event[eventName] ? this.event[eventName].push(callback) : this.event[eventName] = [callback];
    	}
    	emit(eventName) {
    		this.event[eventName] && this.event[eventName].forEach(fn => fn());
    	}
    }

    const mergeSort = (arr) => {
    	if(arr.length<=1) return arr;
    	let len = arr.length,
    		mid = Math.floor(len/2),
    		left = arr.slice(0, mid),
    		right = arr.slice(mid);
		return mergeList(mergeSort(left), mergeSort(right));
    }
    const mergeList = (left, right) => {
    	let result = [];
    	while(left.length && right.length) {
    		left[0]>right[0] ? result.push(right.shift()) : result.push(left.shift());
    	}
    	return result.concat(left, right);
    }
    console.log("归并",mergeSort([13,43,1,9,22,7,11,1,6,9]));



    const PENDING = "PENDING";
    const FULFILLED = "FULFILLED";
    const REJECTED = "REJECTED";
    class myPromise {
    	constructor(executor) {
    		this.status = PENDING;
    		this.value = undefined;
    		this.reason = undefined;
    		this.onResolvedCallbacks = [];
    		this.onRejectedCallbacks = [];
    		let resolve = (value) => {
    			if(this.status === PENDING) {
    				this.status = FULFILLED;
    				this.value = value;
    				this.onResolvedCallbacks.forEach(fn => fn());
    			}
    		}
    		let reject = (reason) => {
    			if(this.status === PENDING) {
    				this.status = REJECTED;
    				this.reason = reason;
    				this.onRejectedCallbacks.forEach(fn => fn());
    			}
    		}
    		try{
    			executor(resolve, reject);
    		}catch(e) {
    			reject(e);
    		}
    	}
    	then(onResolved, onRejected) {
    		const self = this;
    		let promise2;
    		onResolved = typeof onResolved === 'function' ? onResolved : v => v;
    		onRejected = typeof onRejected === 'function' ? onRejected : e => { throw e };
    		if(self.status === FULFILLED) {
    			return promise2 = new myPromise((resolve, reject) => {
    				try{
    					const x = onResolved(self.value);
    					if(x instanceof myPromise) x.then(resolve, reject);
    					resolve(x);
    				}catch(e) {
    					reject(e);
    				}
    			})
    		}
    		if(self.status === REJECTED) {
    			return promise2 = new myPromise((resolve, reject) => {
    				try{
    					const x = onRejected(self.reason);
    					if(x instanceof myPromise) x.then(resolve, reject);
    				}catch(e) {
    					reject(e);
    				}
    			})
    		}
    		if(self.status === PENDING) {
    			return promise2 = new myPromise((resolve, reject) => {
    				self.onResolvedCallbacks.push(() => {
    					try{
	    					const x = onResolved(self.value);
	    					if(x instanceof myPromise) x.then(resolve, reject);
	    					resolve(x);
	    				}catch(e) {
	    					reject(e);
	    				}
    				})
    				self.onRejectedCallbacks.push(() => {
    					try{
	    					const x = onRejected(self.reason);
	    					if(x instanceof myPromise) x.then(resolve, reject);
	    				}catch(e) {
	    					reject(e);
	    				}
    				})
    			})
    		}	
    	}
    	catch(onRejected) {
    		return this.then(null, onRejected);
    	}
    	static resolve(value) {
    		if(value instanceof myPromise) return value;
    		return new myPromise((resolve, reject) => {
    			resolve(value);
    		})
    	}
    	static all(values) {
    		if(Array.isArray(values)) {
    			return new myPromise((resolve,reject) => {
    				let idx = 0;
    				let result = [];
    				for(let i=0; i<values.length; i++) {
    					myPromise.resolve(values[i]).then(res => {
    						result[i] = res;
    						idx++;
    						if(idx === values.length) resolve(result);
    					}).catch(e => {
    						reject(e);
    					})
    				}
    			})
    		}else {
    			return new TypeError('not array');
    		}
    	}
    	static race(values) {
    		if(Array.isArray(values)) {
    			return new myPromise((resolve,reject) => {
    				for(let i=0; i<values.length; i++) {
    					myPromise.resolve(values[i]).then(res => {
    						return resolve(res);
    					}).catch(e => {
    						reject(e);
    					})
    				}
    			})
    		}else {
    			return new TypeError('not array');
    		}
    	}
    }
    const jest = new myPromise((resolve, reject) => {
    	setTimeout(() => {
    		resolve("done");
    	}, 3000)
    })
 	jest.then().then().then(res => {
 		console.log('res', res)
 	}).catch(e => {
 		console.log('reject', e)
 	})

 	const jest1 = new myPromise((resolve, reject) => {
    	setTimeout(() => {
    		resolve("done1");
    	}, 3000)
    })
    const jest2 = new myPromise((resolve, reject) => {
    	setTimeout(() => {
    		resolve("done2");
    	}, 400)
    })
    const jest3 = new myPromise((resolve, reject) => {
    	setTimeout(() => {
    		resolve("done3");
    	}, 1000)
    })
    myPromise.all([jest, jest1, jest2, jest3]).then(res => {
    	console.log('all', res)
    })
    myPromise.race([jest, jest1, jest2, jest3]).then(res => {
    	console.log('race', res)
    })

    const sleep = delay => {
    	return new Promise((resolve, rejcet) => {
    		setTimeout(resolve, delay);
    	})
    }
    sleep(5000).then(res => {
    	console.log(1)
    })


</script>
</body>
</html>